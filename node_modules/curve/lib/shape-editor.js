(function() {
  var CompositeDisposable, Point, RectangleSelection, ShapeEditor, Size, normalizePositionAndSize;

  CompositeDisposable = require('event-kit').CompositeDisposable;

  Point = require('./point');

  Size = require('./size');

  RectangleSelection = require('./rectangle-selection');

  normalizePositionAndSize = require('./utils').normalizePositionAndSize;

  module.exports = ShapeEditor = (function() {
    ShapeEditor.prototype.handleSize = 9;

    ShapeEditor.prototype.cornerPositionByIndex = ['topLeft', 'topRight', 'bottomRight', 'bottomLeft'];

    function ShapeEditor(svgDocument) {
      this.svgDocument = svgDocument;
      this.object = null;
      this.toolLayer = this.svgDocument.getToolLayer();
      this.rectangleSelection = new RectangleSelection(this.svgDocument);
    }

    ShapeEditor.prototype.isActive = function() {
      return !!this.object;
    };

    ShapeEditor.prototype.getActiveObject = function() {
      return this.object;
    };

    ShapeEditor.prototype.activateObject = function(object) {
      this.deactivate();
      if (object != null) {
        this.object = object;
        this._bindToObject(this.object);
        this._setupCornerNodes();
        this.rectangleSelection.setObject(object);
        this.render();
        return this.show();
      }
    };

    ShapeEditor.prototype.deactivate = function() {
      this.rectangleSelection.setObject(null);
      this.hide();
      this._unbindFromObject();
      return this.object = null;
    };

    ShapeEditor.prototype.hide = function() {
      var ref;
      this.visible = false;
      return (ref = this.cornerHandles) != null ? ref.hide() : void 0;
    };

    ShapeEditor.prototype.show = function(toFront) {
      var ref;
      this.visible = true;
      return (ref = this.cornerHandles) != null ? ref.show() : void 0;
    };

    ShapeEditor.prototype.render = function() {
      var corner, cornerPosition, i, index, len, point, position, ref, size, transform;
      if (this.object == null) {
        return;
      }
      size = this.object.get('size');
      position = this.object.get('position');
      transform = this.object.get('transform');
      ref = this.cornerHandles.members;
      for (index = i = 0, len = ref.length; i < len; index = ++i) {
        corner = ref[index];
        cornerPosition = this.cornerPositionByIndex[index];
        point = this._getPointForCornerPosition(cornerPosition, position, size);
        corner.attr({
          x: point.x - this.handleSize / 2,
          y: point.y - this.handleSize / 2,
          transform: transform
        });
      }
    };


    /*
    Section: Event Handlers
     */

    ShapeEditor.prototype.onChangeObject = function(arg) {
      var object, value;
      object = arg.object, value = arg.value;
      if ((value.size != null) || (value.position != null) || (value.transform != null)) {
        return this.render();
      }
    };

    ShapeEditor.prototype.onStartDraggingCornerHandle = function(cornerPosition) {
      this._startSize = this.object.get('size');
      return this._startPosition = this.object.get('position');
    };

    ShapeEditor.prototype.onDraggingCornerHandle = function(cornerPosition, delta, event) {
      var anchor, changedPoint;
      switch (cornerPosition) {
        case 'topLeft':
          anchor = this._getPointForCornerPosition('bottomRight', this._startPosition, this._startSize);
          changedPoint = this._getPointForCornerPosition('topLeft', this._startPosition, this._startSize).add(delta);
          break;
        case 'topRight':
          anchor = this._getPointForCornerPosition('bottomLeft', this._startPosition, this._startSize);
          changedPoint = this._getPointForCornerPosition('topRight', this._startPosition, this._startSize).add(delta);
          break;
        case 'bottomRight':
          anchor = this._getPointForCornerPosition('topLeft', this._startPosition, this._startSize);
          changedPoint = this._getPointForCornerPosition('bottomRight', this._startPosition, this._startSize).add(delta);
          break;
        case 'bottomLeft':
          anchor = this._getPointForCornerPosition('topRight', this._startPosition, this._startSize);
          changedPoint = this._getPointForCornerPosition('bottomLeft', this._startPosition, this._startSize).add(delta);
      }
      return this.object.set(normalizePositionAndSize(anchor, changedPoint, event.shiftKey));
    };


    /*
    Section: Private Methods
     */

    ShapeEditor.prototype._bindToObject = function(object) {
      if (!object) {
        return;
      }
      this.objectSubscriptions = new CompositeDisposable;
      return this.objectSubscriptions.add(object.on('change', this.onChangeObject.bind(this)));
    };

    ShapeEditor.prototype._unbindFromObject = function() {
      var ref;
      if ((ref = this.objectSubscriptions) != null) {
        ref.dispose();
      }
      return this.objectSubscriptions = null;
    };

    ShapeEditor.prototype._setupCornerNodes = function() {
      var corner, cornerPosition, i, index, len, ref;
      if (this.cornerHandles != null) {
        return;
      }
      this.cornerHandles = this.toolLayer.set();
      this.cornerHandles.add(this.toolLayer.rect(this.handleSize, this.handleSize), this.toolLayer.rect(this.handleSize, this.handleSize), this.toolLayer.rect(this.handleSize, this.handleSize), this.toolLayer.rect(this.handleSize, this.handleSize));
      this.cornerHandles.mousedown((function(_this) {
        return function(e) {
          e.stopPropagation();
          return false;
        };
      })(this));
      ref = this.cornerHandles.members;
      for (index = i = 0, len = ref.length; i < len; index = ++i) {
        corner = ref[index];
        corner.node.setAttribute('class', 'shape-editor-handle');
        corner.draggable();
        cornerPosition = this.cornerPositionByIndex[index];
        corner.dragmove = this.onDraggingCornerHandle.bind(this, cornerPosition);
        corner.dragstart = this.onStartDraggingCornerHandle.bind(this, cornerPosition);
        corner.dragend = (function(_this) {
          return function() {
            return _this._startPosition = null;
          };
        })(this);
      }
    };

    ShapeEditor.prototype._getPointForCornerPosition = function(cornerPosition, position, size) {
      switch (cornerPosition) {
        case 'topLeft':
          return position;
        case 'topRight':
          return position.add([size.width, 0]);
        case 'bottomRight':
          return position.add([size.width, size.height]);
        case 'bottomLeft':
          return position.add([0, size.height]);
      }
    };

    return ShapeEditor;

  })();

}).call(this);
