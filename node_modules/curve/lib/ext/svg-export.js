(function() {
  var SVG;

  SVG = require('../../vendor/svg');

  SVG.extend(SVG.Element, {
    "export": function(options, level) {
      var height, i, isRootSvgElement, j, k, l, name, node, ref, ref1, ref2, width;
      name = this.node.nodeName;
      node = '';
      isRootSvgElement = name === 'svg' && !level;
      options = options || {};
      if (!options.exclude || !options.exclude.call(this)) {
        options = options || {};
        level = level || 0;
        if (isRootSvgElement) {
          node += this._whitespaced('<?xml version="1.0" encoding="UTF-8"?>', options.whitespace, level);
          width = this.attr('width');
          height = this.attr('height');
          if (options.width) {
            this.attr('width', options.width);
          }
          if (options.height) {
            this.attr('height', options.height);
          }
        }
        node += this._whitespaced('<' + name + this.attrToString() + '>', options.whitespace, level);
        if (isRootSvgElement) {
          this.attr({
            width: width,
            height: height
          });
          node += this._whitespaced('<desc>Created with Curve</desc>', options.whitespace, level + 1);
          if (this._defs) {
            node += this._whitespaced('<defs>', options.whitespace, level + 1);
            for (i = j = 0, ref = this._defs.children().length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
              node += this._defs.children()[i]["export"](options, level + 2);
            }
            node += this._whitespaced('</defs>', options.whitespace, level + 1);
          }
        }
        if (this instanceof SVG.Container) {
          for (i = k = 0, ref1 = this.children().length; 0 <= ref1 ? k < ref1 : k > ref1; i = 0 <= ref1 ? ++k : --k) {
            node += this.children()[i]["export"](options, level + 1);
          }
        } else if (this instanceof SVG.Text) {
          for (i = l = 0, ref2 = this.lines.length; 0 <= ref2 ? l < ref2 : l > ref2; i = 0 <= ref2 ? ++l : --l) {
            node += this.lines[i]["export"](options, level + 1);
          }
        }
        if (this instanceof SVG.TSpan) {
          node += this._whitespaced(this.node.firstChild.nodeValue, options.whitespace, level + 1);
        }
        node += this._whitespaced('</' + name + '>', options.whitespace, level);
      }
      return node;
    },
    exportAttr: function(attr) {
      if (arguments.length === 0) {
        return this.data('svg-export-attr');
      }
      return this.data('svg-export-attr', attr);
    },
    attrToString: function() {
      var attr, data, exportAttrs, isGeneratedId, key, value;
      attr = [];
      data = this.exportAttr();
      exportAttrs = this.attr();
      if (typeof data === 'object') {
        for (key in data) {
          if (key !== 'data-svg-export-attr') {
            exportAttrs[key] = data[key];
          }
        }
      }
      for (key in exportAttrs) {
        value = exportAttrs[key];
        if (key === 'xlink') {
          key = 'xmlns:xlink';
        }
        isGeneratedId = key === 'id' && value.indexOf('Svgjs') > -1;
        if (!isGeneratedId && key !== 'data-svg-export-attr' && (key !== 'stroke' || parseFloat(exportAttrs['stroke-width']) > 0)) {
          attr.push(key + '="' + value + '"');
        }
      }
      if (attr.length) {
        return ' ' + attr.join(' ');
      } else {
        return '';
      }
    },
    _whitespaced: function(value, add, level) {
      var i, j, ref, space, whitespace;
      if (add) {
        whitespace = '';
        space = add === true ? '  ' : add || '';
        if (level) {
          for (i = j = ref = level - 1; ref <= 0 ? j <= 0 : j >= 0; i = ref <= 0 ? ++j : --j) {
            whitespace += space;
          }
        }
        value = whitespace + value + '\n';
      }
      return value;
    }
  });

}).call(this);
