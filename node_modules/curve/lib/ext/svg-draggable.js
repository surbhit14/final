(function() {
  var SVG, TranslateRegex, attachDragEvents, detachDragEvents, onDrag, onEnd, onStart;

  SVG = require('../../vendor/svg');

  TranslateRegex = /translate\(([-0-9]+) ([-0-9]+)\)/;

  SVG.extend(SVG.Element, {
    draggable: function(startEvent) {
      var dragHandler, element, endHandler, startHandler;
      element = this;
      if (typeof this.fixed === "function") {
        this.fixed();
      }
      startHandler = function(event) {
        onStart(element, event);
        return attachDragEvents(dragHandler, endHandler);
      };
      dragHandler = function(event) {
        return onDrag(element, event);
      };
      endHandler = function(event) {
        onEnd(element, event);
        return detachDragEvents(dragHandler, endHandler);
      };
      element.on('mousedown', startHandler);
      element.fixed = function() {
        element.off('mousedown', startHandler);
        detachDragEvents();
        startHandler = dragHandler = endHandler = null;
        return element;
      };
      if (startEvent != null) {
        startHandler(startEvent);
      }
      return this;
    }
  });

  attachDragEvents = function(dragHandler, endHandler) {
    SVG.on(window, 'mousemove', dragHandler);
    return SVG.on(window, 'mouseup', endHandler);
  };

  detachDragEvents = function(dragHandler, endHandler) {
    SVG.off(window, 'mousemove', dragHandler);
    return SVG.off(window, 'mouseup', endHandler);
  };

  onStart = function(element, event) {
    var parent, rotation, translation, x, y, zoom;
    if (event == null) {
      event = window.event;
    }
    parent = element.parent(SVG.Nested) || element(SVG.Doc);
    element.startEvent = event;
    x = y = 0;
    translation = TranslateRegex.exec(element.attr('transform'));
    if (translation != null) {
      x = parseInt(translation[1]);
      y = parseInt(translation[2]);
    }
    zoom = parent.viewbox().zoom;
    rotation = element.transform('rotation') * Math.PI / 180;
    element.startPosition = {
      x: x,
      y: y,
      zoom: zoom,
      rotation: rotation
    };
    if (typeof element.dragstart === "function") {
      element.dragstart({
        x: 0,
        y: 0,
        zoom: zoom
      }, event);
    }
    if (event.preventDefault) {
      return event.preventDefault();
    } else {
      return event.returnValue = false;
    }
  };

  onDrag = function(element, event) {
    var delta, rotation, x, y;
    if (event == null) {
      event = window.event;
    }
    if (element.startEvent) {
      rotation = element.startPosition.rotation;
      delta = {
        x: event.pageX - element.startEvent.pageX,
        y: event.pageY - element.startEvent.pageY,
        zoom: element.startPosition.zoom
      };

      /* caculate new position [with rotation correction] */
      x = element.startPosition.x + (delta.x * Math.cos(rotation) + delta.y * Math.sin(rotation)) / element.startPosition.zoom;
      y = element.startPosition.y + (delta.y * Math.cos(rotation) + delta.x * Math.sin(-rotation)) / element.startPosition.zoom;
      element.transform({
        x: x,
        y: y
      });
      return typeof element.dragmove === "function" ? element.dragmove(delta, event) : void 0;
    }
  };

  onEnd = function(element, event) {
    var delta;
    if (event == null) {
      event = window.event;
    }
    delta = {
      x: event.pageX - element.startEvent.pageX,
      y: event.pageY - element.startEvent.pageY,
      zoom: element.startPosition.zoom
    };
    element.startEvent = null;
    element.startPosition = null;
    return typeof element.dragend === "function" ? element.dragend(delta, event) : void 0;
  };

}).call(this);
