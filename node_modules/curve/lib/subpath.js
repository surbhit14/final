(function() {
  var CompositeDisposable, Emitter, Point, Subpath, ref,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    slice = [].slice;

  ref = require('event-kit'), Emitter = ref.Emitter, CompositeDisposable = ref.CompositeDisposable;

  Point = require('./point');

  module.exports = Subpath = (function() {
    function Subpath(arg) {
      var nodes, ref1;
      ref1 = arg != null ? arg : {}, this.path = ref1.path, this.closed = ref1.closed, nodes = ref1.nodes;
      this.onNodeChange = bind(this.onNodeChange, this);
      this.emitter = new Emitter;
      this.nodes = [];
      this.setNodes(nodes);
      this.closed = !!this.closed;
    }

    Subpath.prototype.on = function() {
      var args, ref1;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      return (ref1 = this.emitter).on.apply(ref1, args);
    };

    Subpath.prototype.toString = function() {
      return "Subpath " + (this.toPathString());
    };

    Subpath.prototype.toPathString = function() {
      var closePath, j, lastNode, lastPoint, len, makeCurve, node, path, ref1;
      path = '';
      lastPoint = null;
      makeCurve = function(fromNode, toNode) {
        var curve;
        curve = '';
        if (fromNode.handleOut || toNode.handleIn) {
          curve = [];
          curve = curve.concat(fromNode.getAbsoluteHandleOut().toArray());
          curve = curve.concat(toNode.getAbsoluteHandleIn().toArray());
          curve = curve.concat(toNode.point.toArray());
          curve = "C" + (curve.join(','));
        } else if (fromNode.point.x === toNode.point.x) {
          curve = "V" + toNode.point.y;
        } else if (fromNode.point.y === toNode.point.y) {
          curve = "H" + toNode.point.x;
        } else {
          curve = "L" + (toNode.point.toArray().join(','));
        }
        return curve;
      };
      closePath = function(firstNode, lastNode) {
        var closingPath;
        if (!(firstNode && lastNode)) {
          return '';
        }
        closingPath = '';
        if (lastNode.handleOut || firstNode.handleIn) {
          closingPath += makeCurve(lastNode, firstNode);
        }
        return closingPath += 'Z';
      };
      ref1 = this.nodes;
      for (j = 0, len = ref1.length; j < len; j++) {
        node = ref1[j];
        if (path) {
          path += makeCurve(lastNode, node);
        } else {
          path += 'M' + node.point.toArray().join(',');
        }
        lastNode = node;
      }
      if (this.closed) {
        path += closePath(this.nodes[0], this.nodes[this.nodes.length - 1]);
      }
      return path;
    };

    Subpath.prototype.getNodes = function() {
      return this.nodes;
    };

    Subpath.prototype.setNodes = function(nodes) {
      if (!(nodes && Array.isArray(nodes))) {
        return;
      }
      this._unbindNodes();
      this._bindNodes(nodes);
      this.nodes = nodes;
      return this.emitter.emit('change', this);
    };

    Subpath.prototype.addNode = function(node) {
      return this.insertNode(node, this.nodes.length);
    };

    Subpath.prototype.insertNode = function(node, index) {
      this._bindNode(node);
      this.nodes.splice(index, 0, node);
      this.emitter.emit('insert:node', {
        subpath: this,
        index: index,
        node: node
      });
      return this.emitter.emit('change', this);
    };

    Subpath.prototype.removeNode = function(node) {
      var index;
      index = this.nodes.indexOf(node);
      if (index > -1) {
        this.nodes.splice(index, 1);
        this.emitter.emit('remove:node', {
          subpath: this,
          index: index,
          node: node
        });
        return this.emitter.emit('change', this);
      }
    };

    Subpath.prototype.isClosed = function() {
      return this.closed;
    };

    Subpath.prototype.close = function() {
      this.closed = true;
      return this.emitter.emit('change', this);
    };

    Subpath.prototype.translate = function(point) {
      var j, len, node, ref1;
      point = Point.create(point);
      ref1 = this.nodes;
      for (j = 0, len = ref1.length; j < len; j++) {
        node = ref1[j];
        node.translate(point);
      }
    };

    Subpath.prototype.onNodeChange = function() {
      return this.emitter.emit('change', this);
    };

    Subpath.prototype._bindNode = function(node) {
      node.setPath(this.path);
      if (this.nodeChangeSubscriptions == null) {
        this.nodeChangeSubscriptions = new CompositeDisposable;
      }
      return this.nodeChangeSubscriptions.add(node.on('change', this.onNodeChange));
    };

    Subpath.prototype._bindNodes = function(nodes) {
      var j, len, node;
      for (j = 0, len = nodes.length; j < len; j++) {
        node = nodes[j];
        this._bindNode(node);
      }
    };

    Subpath.prototype._unbindNodes = function() {
      var j, len, node, ref1, ref2;
      ref1 = this.nodes;
      for (j = 0, len = ref1.length; j < len; j++) {
        node = ref1[j];
        node.setPath(null);
      }
      if ((ref2 = this.nodeChangeSubscriptions) != null) {
        ref2.dispose();
      }
      return this.nodeChangeSubscriptions = null;
    };

    Subpath.prototype._findNodeIndex = function(node) {
      var i, j, ref1;
      for (i = j = 0, ref1 = this.nodes.length; 0 <= ref1 ? j < ref1 : j > ref1; i = 0 <= ref1 ? ++j : --j) {
        if (this.nodes[i] === node) {
          return i;
        }
      }
      return -1;
    };

    return Subpath;

  })();

}).call(this);
