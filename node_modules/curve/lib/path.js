(function() {
  var CompositeDisposable, DefaultAttrs, Delegator, Draggable, Emitter, ObjectAssign, Path, PathModel, Point, Utils, ref,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  ref = require('event-kit'), Emitter = ref.Emitter, CompositeDisposable = ref.CompositeDisposable;

  Delegator = require('delegato');

  ObjectAssign = require('object-assign');

  Utils = require('./utils');

  Point = require('./point');

  Draggable = require('./draggable-mixin');

  PathModel = require('./path-model');

  DefaultAttrs = {
    fill: '#eee',
    stroke: 'none'
  };

  module.exports = Path = (function() {
    Draggable.includeInto(Path);

    Delegator.includeInto(Path);

    Path.delegatesMethods('on', {
      toProperty: 'emitter'
    });

    Path.delegatesMethods('get', 'set', 'getID', 'getType', 'getNodes', 'getSubpaths', 'addNode', 'insertNode', 'removeNode', 'createSubpath', 'close', 'isClosed', 'translate', {
      toProperty: 'model'
    });

    function Path(svgDocument1, options) {
      this.svgDocument = svgDocument1;
      if (options == null) {
        options = {};
      }
      this.onModelChange = bind(this.onModelChange, this);
      this.emitter = new Emitter;
      this._draggingEnabled = false;
      this.model = new PathModel;
      this.model.on('change', this.onModelChange);
      this.model.on('insert:node', this._forwardEvent.bind(this, 'insert:node'));
      this.model.on('remove:node', this._forwardEvent.bind(this, 'remove:node'));
      this._setupSVGObject(options);
      this.svgDocument.registerObject(this);
    }


    /*
    Section: Public Methods
     */

    Path.prototype.toString = function() {
      return "Path " + this.id + " " + (this.model.toString());
    };

    Path.prototype.getModel = function() {
      return this.model;
    };

    Path.prototype.getPosition = function() {
      return new Point(this.svgEl.x(), this.svgEl.y());
    };

    Path.prototype.remove = function() {
      this.svgEl.remove();
      return this.emitter.emit('remove', {
        object: this
      });
    };

    Path.prototype.updateFromAttributes = function() {
      var fill, path, transform;
      path = this.svgEl.attr('d');
      transform = this.svgEl.attr('transform');
      fill = this.svgEl.attr('fill');
      return this.model.set({
        transform: transform,
        path: path,
        fill: fill
      });
    };

    Path.prototype.render = function(svgEl) {
      var fill, pathStr;
      if (svgEl == null) {
        svgEl = this.svgEl;
      }
      pathStr = this.model.get('path');
      fill = this.model.get('fill');
      if (pathStr) {
        svgEl.attr({
          d: pathStr
        });
      }
      if (fill && fill !== '#000000') {
        svgEl.attr({
          fill: this.model.get('fill')
        });
      }
      return svgEl.attr({
        transform: this.model.get('transform') || null
      });
    };

    Path.prototype.cloneElement = function(svgDocument) {
      var el;
      if (svgDocument == null) {
        svgDocument = this.svgDocument;
      }
      el = svgDocument.getObjectLayer().path();
      this.render(el);
      return el;
    };


    /*
    Section: Event Handlers
     */

    Path.prototype.onModelChange = function(args) {
      this.render();
      args.object = this;
      return this.emitter.emit('change', args);
    };


    /*
    Section: Private Methods
     */

    Path.prototype._forwardEvent = function(eventName, args) {
      args.object = this;
      return this.emitter.emit(eventName, args);
    };

    Path.prototype._setupSVGObject = function(options) {
      this.svgEl = options.svgEl;
      if (!this.svgEl) {
        this.svgEl = this.svgDocument.getObjectLayer().path().attr(ObjectAssign({}, DefaultAttrs, options));
      }
      Utils.setObjectOnNode(this.svgEl.node, this);
      return this.updateFromAttributes();
    };

    return Path;

  })();

}).call(this);
