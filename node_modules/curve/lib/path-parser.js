(function() {
  var COMMAND, NUMBER, Node, groupCommands, lexPath, parsePath, parseTokens, ref;

  Node = require("./node");

  ref = ['COMMAND', 'NUMBER'], COMMAND = ref[0], NUMBER = ref[1];

  parsePath = function(pathString) {
    var tokens;
    tokens = lexPath(pathString);
    return parseTokens(groupCommands(tokens));
  };

  parseTokens = function(groupedCommands) {
    var addNewSubpath, command, createNode, currentPoint, currentSubpath, hasMoved, i, isRelative, iterateOverParameterSets, j, k, l, len, len1, makeAbsolute, node, ref1, ref2, ref3, ref4, result, setSize, slicePoint, subpath;
    result = {
      subpaths: []
    };
    if (groupedCommands.length === 1 && ((ref1 = groupedCommands[0].type) === 'M' || ref1 === 'm')) {
      return result;
    }
    currentPoint = null;
    currentSubpath = null;
    addNewSubpath = function(movePoint) {
      var node;
      node = new Node(movePoint);
      currentSubpath = {
        closed: false,
        nodes: [node]
      };
      result.subpaths.push(currentSubpath);
      return node;
    };
    slicePoint = function(array, index) {
      return [array[index], array[index + 1]];
    };
    makeAbsolute = function(array) {
      var i, j, len, results, val;
      if (currentPoint != null) {
        results = [];
        for (i = j = 0, len = array.length; j < len; i = ++j) {
          val = array[i];
          results.push(val + currentPoint[i % 2]);
        }
        return results;
      } else {
        return array;
      }
    };
    createNode = function(point, commandIndex) {
      var firstNode, nextCommand, node, ref2;
      currentPoint = point;
      node = null;
      firstNode = currentSubpath.nodes[0];
      nextCommand = groupedCommands[commandIndex + 1];
      if (!(nextCommand && ((ref2 = nextCommand.type) === 'z' || ref2 === 'Z') && firstNode && firstNode.point.equals(currentPoint))) {
        node = new Node(currentPoint);
        currentSubpath.nodes.push(node);
      }
      return node;
    };
    iterateOverParameterSets = function(command, setSize, isRelative, callback) {
      var j, maxIndex, minindex, paramSet, ref2, setIndex, sets;
      sets = command.parameters.length / setSize;
      for (setIndex = j = 0, ref2 = sets; 0 <= ref2 ? j < ref2 : j > ref2; setIndex = 0 <= ref2 ? ++j : --j) {
        minindex = setIndex * setSize + 0;
        maxIndex = setIndex * setSize + setSize;
        paramSet = command.parameters.slice(minindex, maxIndex);
        if (isRelative) {
          paramSet = makeAbsolute(paramSet);
        }
        callback(paramSet, setIndex);
      }
    };
    for (i = j = 0, ref2 = groupedCommands.length; 0 <= ref2 ? j < ref2 : j > ref2; i = 0 <= ref2 ? ++j : --j) {
      command = groupedCommands[i];
      switch (command.type) {
        case 'M':
        case 'm':
          hasMoved = false;
          setSize = 2;
          isRelative = command.type === 'm';
          iterateOverParameterSets(command, setSize, isRelative, function(paramSet) {
            if (hasMoved) {
              return createNode(paramSet, i);
            } else {
              hasMoved = true;
              currentPoint = paramSet;
              return addNewSubpath(currentPoint);
            }
          });
          break;
        case 'L':
        case 'l':
          setSize = 2;
          isRelative = command.type === 'l';
          iterateOverParameterSets(command, setSize, isRelative, function(paramSet) {
            return createNode(slicePoint(paramSet, 0), i);
          });
          break;
        case 'H':
        case 'h':
          setSize = 1;
          isRelative = command.type === 'h';
          iterateOverParameterSets(command, setSize, isRelative, function(paramSet) {
            return createNode([paramSet[0], currentPoint[1]], i);
          });
          break;
        case 'V':
        case 'v':
          setSize = 1;
          isRelative = command.type === 'v';
          iterateOverParameterSets(command, setSize, false, function(paramSet) {
            var val;
            val = paramSet[0];
            if (isRelative) {
              val += currentPoint[1];
            }
            return createNode([currentPoint[0], val], i);
          });
          break;
        case 'C':
        case 'c':
          setSize = 6;
          isRelative = command.type === 'c';
          iterateOverParameterSets(command, setSize, isRelative, function(paramSet) {
            var firstNode, handleIn, handleOut, lastNode, node;
            currentPoint = slicePoint(paramSet, 4);
            handleIn = slicePoint(paramSet, 2);
            handleOut = slicePoint(paramSet, 0);
            lastNode = currentSubpath.nodes[currentSubpath.nodes.length - 1];
            lastNode.setAbsoluteHandleOut(handleOut);
            if (node = createNode(currentPoint, i)) {
              return node.setAbsoluteHandleIn(handleIn);
            } else {
              firstNode = currentSubpath.nodes[0];
              return firstNode.setAbsoluteHandleIn(handleIn);
            }
          });
          break;
        case 'Q':
        case 'q':
          setSize = 4;
          isRelative = command.type === 'q';
          iterateOverParameterSets(command, setSize, isRelative, function(paramSet) {
            var firstNode, handleIn, handleOut, lastNode, node;
            currentPoint = slicePoint(paramSet, 2);
            handleIn = handleOut = slicePoint(paramSet, 0);
            lastNode = currentSubpath.nodes[currentSubpath.nodes.length - 1];
            lastNode.setAbsoluteHandleOut(handleOut);
            if (node = createNode(currentPoint, i)) {
              return node.setAbsoluteHandleIn(handleIn);
            } else {
              firstNode = currentSubpath.nodes[0];
              return firstNode.setAbsoluteHandleIn(handleIn);
            }
          });
          break;
        case 'S':
        case 's':
          setSize = 4;
          isRelative = command.type === 's';
          iterateOverParameterSets(command, setSize, isRelative, function(paramSet) {
            var firstNode, handleIn, lastNode, node;
            currentPoint = slicePoint(paramSet, 2);
            handleIn = slicePoint(paramSet, 0);
            lastNode = currentSubpath.nodes[currentSubpath.nodes.length - 1];
            lastNode.join('handleIn');
            if (node = createNode(currentPoint, i)) {
              return node.setAbsoluteHandleIn(handleIn);
            } else {
              firstNode = currentSubpath.nodes[0];
              return firstNode.setAbsoluteHandleIn(handleIn);
            }
          });
          break;
        case 'T':
        case 't':
          setSize = 2;
          isRelative = command.type === 'q';
          iterateOverParameterSets(command, setSize, isRelative, function(paramSet) {
            var firstNode, handleIn, lastNode, node;
            currentPoint = slicePoint(paramSet, 0);
            lastNode = currentSubpath.nodes[currentSubpath.nodes.length - 1];
            lastNode.join('handleIn');
            handleIn = lastNode.getAbsoluteHandleOut();
            if (node = createNode(currentPoint, i)) {
              return node.setAbsoluteHandleIn(handleIn);
            } else {
              firstNode = currentSubpath.nodes[0];
              return firstNode.setAbsoluteHandleIn(handleIn);
            }
          });
          break;
        case 'Z':
        case 'z':
          currentSubpath.closed = true;
      }
    }
    ref3 = result.subpaths;
    for (k = 0, len = ref3.length; k < len; k++) {
      subpath = ref3[k];
      ref4 = subpath.nodes;
      for (l = 0, len1 = ref4.length; l < len1; l++) {
        node = ref4[l];
        node.computeIsjoined();
      }
    }
    return result;
  };

  groupCommands = function(pathTokens) {
    var command, commands, i, j, nextToken, ref1, token;
    commands = [];
    for (i = j = 0, ref1 = pathTokens.length; 0 <= ref1 ? j < ref1 : j > ref1; i = 0 <= ref1 ? ++j : --j) {
      token = pathTokens[i];
      if (token.type !== COMMAND) {
        continue;
      }
      command = {
        type: token.string,
        parameters: []
      };
      while (nextToken = pathTokens[i + 1]) {
        if (nextToken.type === NUMBER) {
          command.parameters.push(parseFloat(nextToken.string));
          i++;
        } else {
          break;
        }
      }
      commands.push(command);
    }
    return commands;
  };

  lexPath = function(pathString) {
    var ch, currentToken, j, len, numberMatch, saveCurrentToken, saveCurrentTokenWhenDifferentThan, separatorMatch, tokens;
    numberMatch = '-0123456789.';
    separatorMatch = ' ,\n\t';
    tokens = [];
    currentToken = null;
    saveCurrentTokenWhenDifferentThan = function(command) {
      if (currentToken && currentToken.type !== command) {
        return saveCurrentToken();
      }
    };
    saveCurrentToken = function() {
      if (!currentToken) {
        return;
      }
      if (currentToken.string.join) {
        currentToken.string = currentToken.string.join('');
      }
      tokens.push(currentToken);
      return currentToken = null;
    };
    for (j = 0, len = pathString.length; j < len; j++) {
      ch = pathString[j];
      if (numberMatch.indexOf(ch) > -1) {
        saveCurrentTokenWhenDifferentThan(NUMBER);
        if (ch === '-') {
          saveCurrentToken();
        }
        if (!currentToken) {
          currentToken = {
            type: NUMBER,
            string: []
          };
        }
        currentToken.string.push(ch);
      } else if (separatorMatch.indexOf(ch) > -1) {
        saveCurrentToken();
      } else {
        saveCurrentToken();
        tokens.push({
          type: COMMAND,
          string: ch
        });
      }
    }
    saveCurrentToken();
    return tokens;
  };

  module.exports = {
    lexPath: lexPath,
    parsePath: parsePath,
    groupCommands: groupCommands,
    parseTokens: parseTokens
  };

}).call(this);
