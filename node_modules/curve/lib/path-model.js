(function() {
  var CompositeDisposable, Delegator, Emitter, IDS, Model, PathModel, PathParser, Point, Subpath, Transform, flatten, ref,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  ref = require('event-kit'), Emitter = ref.Emitter, CompositeDisposable = ref.CompositeDisposable;

  Delegator = require('delegato');

  PathParser = require('./path-parser');

  Transform = require('./transform');

  Subpath = require('./subpath');

  Point = require('./point');

  Model = require('./model');

  IDS = 0;

  flatten = function(array) {
    var concat;
    concat = function(accumulator, item) {
      if (Array.isArray(item)) {
        return accumulator.concat(flatten(item));
      } else {
        return accumulator.concat(item);
      }
    };
    return array.reduce(concat, []);
  };

  module.exports = PathModel = (function(superClass) {
    extend(PathModel, superClass);

    function PathModel() {
      this.onSubpathChange = bind(this.onSubpathChange, this);
      PathModel.__super__.constructor.call(this, ['transform', 'path', 'fill']);
      this.id = IDS++;
      this.subpaths = [];
      this.transform = new Transform;
      this.addFilter('path', (function(_this) {
        return function(value) {
          return _this._parseFromPathString(value);
        };
      })(this));
      this.addFilter('transform', (function(_this) {
        return function(value) {
          if (value === 'matrix(1,0,0,1,0,0)') {
            return null;
          } else {
            return value;
          }
        };
      })(this));
      this.subscriptions = new CompositeDisposable;
      this.subscriptions.add(this.on('change:transform', (function(_this) {
        return function(arg) {
          var value;
          value = arg.value;
          return _this.transform.setTransformString(value);
        };
      })(this)));
    }

    PathModel.prototype.destroy = function() {
      return this.subscriptions.dispose();
    };


    /*
    Section: Path Details
     */

    PathModel.prototype.getType = function() {
      return 'Path';
    };

    PathModel.prototype.getID = function() {
      return (this.getType()) + "-" + this.id;
    };

    PathModel.prototype.toString = function() {
      return this.getPathString();
    };

    PathModel.prototype.getSubpaths = function() {
      return this.subpaths;
    };

    PathModel.prototype.getNodes = function() {
      var nodes, subpath;
      nodes = (function() {
        var i, len, ref1, results;
        ref1 = this.subpaths;
        results = [];
        for (i = 0, len = ref1.length; i < len; i++) {
          subpath = ref1[i];
          results.push(subpath.getNodes());
        }
        return results;
      }).call(this);
      return flatten(nodes);
    };

    PathModel.prototype.isClosed = function() {
      var i, len, ref1, subpath;
      ref1 = this.subpaths;
      for (i = 0, len = ref1.length; i < len; i++) {
        subpath = ref1[i];
        if (!subpath.isClosed()) {
          return false;
        }
      }
      return true;
    };


    /*
    Section: Position / Size Methods
     */

    PathModel.prototype.translate = function(point) {
      var i, len, ref1, subpath;
      point = Point.create(point);
      ref1 = this.subpaths;
      for (i = 0, len = ref1.length; i < len; i++) {
        subpath = ref1[i];
        subpath.translate(point);
      }
    };

    PathModel.prototype.getTransform = function() {
      return this.transform;
    };


    /*
    Section: Current Subpath stuff
    
    FIXME: the currentSubpath thing will probably leave. depends on how insert
    nodes works in interface.
     */

    PathModel.prototype.addNode = function(node) {
      this._addCurrentSubpathIfNotPresent();
      return this.currentSubpath.addNode(node);
    };

    PathModel.prototype.insertNode = function(node, index) {
      this._addCurrentSubpathIfNotPresent();
      return this.currentSubpath.insertNode(node, index);
    };

    PathModel.prototype.close = function() {
      this._addCurrentSubpathIfNotPresent();
      return this.currentSubpath.close();
    };

    PathModel.prototype.createSubpath = function(args) {
      if (args == null) {
        args = {};
      }
      args.path = this;
      return this.currentSubpath = this._addSubpath(new Subpath(args));
    };

    PathModel.prototype.removeNode = function(node) {
      var i, len, ref1, subpath;
      ref1 = this.subpaths;
      for (i = 0, len = ref1.length; i < len; i++) {
        subpath = ref1[i];
        subpath.removeNode(node);
      }
    };

    PathModel.prototype._addCurrentSubpathIfNotPresent = function() {
      if (!this.currentSubpath) {
        return this.createSubpath();
      }
    };


    /*
    Section: Event Handlers
     */

    PathModel.prototype.onSubpathChange = function(subpath, eventArgs) {
      return this._updatePathString();
    };


    /*
    Section: Private Methods
     */

    PathModel.prototype._addSubpath = function(subpath) {
      this.subpaths.push(subpath);
      this._bindSubpath(subpath);
      this._updatePathString();
      return subpath;
    };

    PathModel.prototype._bindSubpath = function(subpath) {
      if (!subpath) {
        return;
      }
      if (this.subpathSubscriptions == null) {
        this.subpathSubscriptions = new CompositeDisposable;
      }
      this.subpathSubscriptions.add(subpath.on('change', this.onSubpathChange));
      this.subpathSubscriptions.add(subpath.on('insert:node', this._forwardEvent.bind(this, 'insert:node')));
      return this.subpathSubscriptions.add(subpath.on('remove:node', this._forwardEvent.bind(this, 'remove:node')));
    };

    PathModel.prototype._unbindSubpath = function(subpath) {
      if (!subpath) {
        return;
      }
      return subpath.removeAllListeners();
    };

    PathModel.prototype._removeAllSubpaths = function() {
      var ref1;
      if ((ref1 = this.subpathSubscriptions) != null) {
        ref1.dispose();
      }
      this.subpathSubscriptions = null;
      return this.subpaths = [];
    };

    PathModel.prototype._updatePathString = function() {
      return this.set({
        path: this._pathToString()
      }, {
        filter: false
      });
    };

    PathModel.prototype._pathToString = function() {
      var subpath;
      return ((function() {
        var i, len, ref1, results;
        ref1 = this.subpaths;
        results = [];
        for (i = 0, len = ref1.length; i < len; i++) {
          subpath = ref1[i];
          results.push(subpath.toPathString());
        }
        return results;
      }).call(this)).join(' ');
    };

    PathModel.prototype._parseFromPathString = function(pathString) {
      var i, len, parsedPath, parsedSubpath, ref1;
      if (!pathString) {
        return;
      }
      if (pathString === this.pathString) {
        return;
      }
      this._removeAllSubpaths();
      parsedPath = PathParser.parsePath(pathString);
      ref1 = parsedPath.subpaths;
      for (i = 0, len = ref1.length; i < len; i++) {
        parsedSubpath = ref1[i];
        this.createSubpath(parsedSubpath);
      }
      return this._pathToString();
    };

    PathModel.prototype._forwardEvent = function(eventName, args) {
      return this.emitter.emit(eventName, args);
    };

    return PathModel;

  })(Model);

}).call(this);
