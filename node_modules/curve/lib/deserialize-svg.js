(function() {
  var Ellipse, Path, Rectangle, SVG, convertNodes;

  SVG = require("../vendor/svg");

  require("../vendor/svg.parser");

  Path = require("./path");

  Rectangle = require("./rectangle");

  Ellipse = require("./ellipse");

  module.exports = function(svgDocument, svgString) {
    var IMPORT_FNS, objects, parentNode, store;
    IMPORT_FNS = {
      path: function(el) {
        return [
          new Path(svgDocument, {
            svgEl: el
          })
        ];
      },
      rect: function(el) {
        return [
          new Rectangle(svgDocument, {
            svgEl: el
          })
        ];
      },
      circle: function(el) {
        return [
          new Ellipse(svgDocument, {
            svgEl: el
          })
        ];
      },
      ellipse: function(el) {
        return [
          new Ellipse(svgDocument, {
            svgEl: el
          })
        ];
      }
    };
    parentNode = document.createElement('div');
    store = {};
    parentNode.innerHTML = svgString.replace(/\n/, '').replace(/<(\w+)([^<]+?)\/>/g, '<$1$2></$1>');
    objects = [];
    convertNodes(parentNode.childNodes, svgDocument.getSVGRoot(), 0, store, function() {
      var nodeType;
      nodeType = this.node.nodeName;
      if (IMPORT_FNS[nodeType]) {
        objects = objects.concat(IMPORT_FNS[nodeType](this));
      }
      return null;
    });
    parentNode = null;
    return objects;
  };

  convertNodes = function(nodes, context, level, store, block) {
    var attr, child, clips, element, grandchild, i, j, k, l, ref, ref1, ref2, transform, type;
    for (i = k = 0, ref = nodes.length; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {
      element = null;
      child = nodes[i];
      attr = {};
      clips = [];
      type = child.nodeName.toLowerCase();
      attr = SVG.parse.attr(child);
      switch (type) {
        case 'path':
          element = context[type]();
          break;
        case 'polygon':
          element = context[type]();
          break;
        case 'polyline':
          element = context[type]();
          break;
        case 'rect':
          element = context[type](0, 0);
          break;
        case 'circle':
          element = context[type](0, 0);
          break;
        case 'ellipse':
          element = context[type](0, 0);
          break;
        case 'line':
          element = context.line(0, 0, 0, 0);
          break;
        case 'text':
          if (child.childNodes.length === 0) {
            element = context[type](child.textContent);
          } else {
            element = null;
            for (j = l = 0, ref1 = child.childNodes.length; 0 <= ref1 ? l < ref1 : l > ref1; j = 0 <= ref1 ? ++l : --l) {
              grandchild = child.childNodes[j];
              if (grandchild.nodeName.toLowerCase() === 'tspan') {
                if (element === null) {
                  element = context[type](grandchild.textContent);
                } else {
                  element.tspan(grandchild.textContent).attr(SVG.parse.attr(grandchild));
                }
              }
            }
          }
          break;
        case 'image':
          element = context.image(attr['xlink:href']);
          break;
        case 'g':
        case 'svg':
          element = context[type === 'g' ? 'group' : 'nested']();
          convertNodes(child.childNodes, element, level + 1, store, block);
          break;
        case 'defs':
          convertNodes(child.childNodes, context.defs(), level + 1, store, block);
          break;
        case 'use':
          element = context.use();
          break;
        case 'clippath':
        case 'mask':
          element = context[(ref2 = type === 'mask') != null ? ref2 : {
            'mask': 'clip'
          }]();
          convertNodes(child.childNodes, element, level + 1, store, block);
          break;
        case 'lineargradient':
        case 'radialgradient':
          element = context.defs().gradient(type.split('gradient')[0], function(stop) {
            var m, ref3, results;
            results = [];
            for (j = m = 0, ref3 = child.childNodes.length; 0 <= ref3 ? m < ref3 : m > ref3; j = 0 <= ref3 ? ++m : --m) {
              results.push(stop.at({
                offset: 0
              }).attr(SVG.parse.attr(child.childNodes[j])).style(child.childNodes[j].getAttribute('style')));
            }
            return results;
          });
          break;
        case '#comment':
        case '#text':
        case 'metadata':
        case 'desc':
          break;
        default:
          console.log('SVG Import got unexpected type ' + type, child);
      }
      if (element) {
        transform = SVG.parse.transform(attr.transform);
        delete attr.transform;
        element.attr(attr).transform(transform);
        if (element.attr('id')) {
          store[element.attr('id')] = element;
        }
        if (type === 'text') {
          element.rebuild();
        }
        if (typeof block === 'function') {
          block.call(element);
        }
      }
    }
    return context;
  };

}).call(this);
