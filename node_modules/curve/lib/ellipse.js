(function() {
  var DefaultAttrs, Delegator, Draggable, Ellipse, EllipseModel, Emitter, IDS, ObjectAssign, Utils,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  Emitter = require('event-kit').Emitter;

  ObjectAssign = require('object-assign');

  Delegator = require('delegato');

  Utils = require('./utils');

  Draggable = require('./draggable-mixin');

  EllipseModel = require('./ellipse-model');

  DefaultAttrs = {
    cx: 5,
    cy: 5,
    rx: 5,
    ry: 5,
    fill: '#eee',
    stroke: 'none'
  };

  IDS = 0;

  module.exports = Ellipse = (function() {
    Draggable.includeInto(Ellipse);

    Delegator.includeInto(Ellipse);

    Ellipse.delegatesMethods('on', {
      toProperty: 'emitter'
    });

    Ellipse.delegatesMethods('get', 'set', 'getID', 'getType', 'toString', 'translate', {
      toProperty: 'model'
    });

    function Ellipse(svgDocument1, options) {
      this.svgDocument = svgDocument1;
      if (options == null) {
        options = {};
      }
      this.onModelChange = bind(this.onModelChange, this);
      this.emitter = new Emitter;
      this.model = new EllipseModel;
      this._setupSVGObject(options);
      this.model.on('change', this.onModelChange);
      this.svgDocument.registerObject(this);
    }


    /*
    Section: Public Methods
     */

    Ellipse.prototype.remove = function() {
      this.svgEl.remove();
      return this.emitter.emit('remove', {
        object: this
      });
    };

    Ellipse.prototype.updateFromAttributes = function() {
      var fill, height, r, rx, ry, transform, width, x, y;
      r = this.svgEl.attr('r');
      if (r) {
        rx = ry = r;
      } else {
        rx = this.svgEl.attr('rx');
        ry = this.svgEl.attr('ry');
      }
      x = this.svgEl.attr('cx') - rx;
      y = this.svgEl.attr('cy') - ry;
      width = rx * 2;
      height = ry * 2;
      transform = this.svgEl.attr('transform');
      fill = this.svgEl.attr('fill');
      return this.model.set({
        position: [x, y],
        size: [width, height],
        transform: transform,
        fill: fill
      });
    };

    Ellipse.prototype.render = function(svgEl) {
      var attrs, position, size;
      if (svgEl == null) {
        svgEl = this.svgEl;
      }
      position = this.model.get('position');
      size = this.model.get('size');
      attrs = {
        x: position.x,
        y: position.y,
        width: size.width,
        height: size.height
      };
      return svgEl.attr(ObjectAssign({
        transform: this.model.get('transform') || null,
        fill: this.model.get('fill') || null
      }, this._convertPositionAndSizeToCenter(attrs)));
    };

    Ellipse.prototype.cloneElement = function(svgDocument) {
      var el;
      if (svgDocument == null) {
        svgDocument = this.svgDocument;
      }
      el = svgDocument.getObjectLayer().ellipse();
      this.render(el);
      return el;
    };


    /*
    Section: Event Handlers
     */

    Ellipse.prototype.onModelChange = function(args) {
      this.render();
      args.object = this;
      return this.emitter.emit('change', args);
    };


    /*
    Section: Private Methods
     */

    Ellipse.prototype._convertPositionAndSizeToCenter = function(attrs) {
      var cx, cy, height, rx, ry, width, x, y;
      x = attrs.x, y = attrs.y, width = attrs.width, height = attrs.height;
      if (!((x != null) && (y != null) && (width != null) && (height != null))) {
        return {};
      }
      rx = width / 2;
      ry = height / 2;
      cx = x + rx;
      cy = y + ry;
      return {
        rx: rx,
        ry: ry,
        cx: cx,
        cy: cy
      };
    };

    Ellipse.prototype._setupSVGObject = function(options) {
      var attrs;
      this.svgEl = options.svgEl;
      if (!this.svgEl) {
        attrs = ObjectAssign({}, DefaultAttrs, options, this._convertPositionAndSizeToCenter(options));
        delete attrs.x;
        delete attrs.y;
        delete attrs.width;
        delete attrs.height;
        this.svgEl = this.svgDocument.getObjectLayer().ellipse().attr(attrs);
      }
      Utils.setObjectOnNode(this.svgEl.node, this);
      return this.updateFromAttributes();
    };

    return Ellipse;

  })();

}).call(this);
